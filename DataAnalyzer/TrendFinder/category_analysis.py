"""
Code created by William Starling (williamjonas@comcast.net, 251-680-9048)
dspy code whose goal is to analyze a collection of documents for relevent data categories. It does this by analyzing them one at a time using a dspy signature, and updating a single string list and context file to reflect the new information and trends found in the document. 
"""

#For setting up and creating the DSPy signatures and modules needed to search for trends as a part of the bigger data analysis agent.
import dspy
from attachments.dspy import Attachments
import pandas as pd
import os

"""
dspy signature used to analyze a single document to find categories of data that would be relevent to the user..
inputs: document: Attachments (a document fed through the Attachments API to be analyzed)
        categories: List of strings (the data categories that we want to analyze the document for, such as number of violations, address, etc.)
        in_csv: string (the csv file being used to store information the group of documents as a whole. elements are seperated by commas, new rows by new line characters.)
        last_context: string (Important context of the overall goal and previous steps from other agents.)
outputs: next_context: string (the context used, updated with new information if something important is noticed, such as patterns found.)
         out_csv: string (the csv file updated to include the current documents information.)
"""
class cat_analyzer(dspy.Signature):
    """You will receive a single document from a collection of related documents, and given the initial prompt and task description contained in the context string, you will analyze the document and update the list of categories to include new categories found in the current document that would be relevent to the overall goal."""
    document: Attachments = dspy.InputField(
        desc="the current document to analyze")
    in_categories: list[str] = dspy.InputField(
        desc=
        "The categories found so far for the group of documents. These are used as a guide to know what to look for in the document."
    )
    last_context: str = dspy.InputField(
        desc=
        "Important context of the overall goal and previous steps from other agents."
    )
    next_context: str = dspy.OutputField(
        desc=
        "The input context passed on, where new information is optionally added on if thought to be important. New context, if present at all, should be brief to ensure the overall context doesn't get too long."
    )
    out_categories: str = dspy.OutputField(
        desc=
        "The lists of categories updated to include additional important features found in the current document."
    )

"""
dspy module use to analyze a collection of documents as a whole for relevent data categories. documents must be passed in as a list of Attachments objects.
inputs: documents: list of Attachments (a list of documents to be analyzed, as attachment objects. see trend_test.py for an example of how it's used.)
        context: string (the context of the overall goal and previous steps from other agents.)
output:    categories: list of strings (a list of categories that exists as strings. these are used as a guide to know what to look for in each document.)
context: string (the updated context of the instructions, previous agents notes, and this agents notes.)
"""
class categories_analyzer(dspy.Module):

    def __init__(self):
        super().__init__()
        self.doc_analyzer = dspy.ChainOfThought(cat_analyzer)

    def forward(self, documents: list[Attachments], context: str):
        categories = []
        for document in documents:
            result = self.doc_analyzer(document=document,
                                           in_categories=categories,
                                           last_context=context)
            context = result.next_context
            categories = result.out_categories
        #print(doc_summary)
        return categories, context


# ====== THE FOLLOWING CODE WAS GENERATED BY CLAUDE AI FOR THE SAKE OF A COMMAND LINE INTERFACE ======

def get_user_input():
    """Get user input for document paths and context"""
    print("=" * 60)
    print("üîç CATEGORY ANALYZER - COMMAND LINE INTERFACE")
    print("=" * 60)
    
    # Get document paths
    print("\nüìÑ DOCUMENT PATHS:")
    print("Enter document paths (one per line, empty line to finish):")
    document_paths = []
    while True:
        path = input("Document path: ").strip()
        if not path:
            break
        if not os.path.exists(path):
            print(f"‚ö†Ô∏è  Warning: File '{path}' does not exist!")
            continue_anyway = input("Continue anyway? (y/n): ").lower().strip()
            if continue_anyway != 'y':
                continue
        document_paths.append(path)
    
    if not document_paths:
        print("‚ùå No document paths provided. Exiting...")
        return None, None
    
    print(f"‚úÖ Added {len(document_paths)} document(s)")
    
    # Get initial context and prompt
    print("\nüí≠ ANALYSIS CONTEXT:")
    print("Please describe what types of information you're looking for in the documents:")
    context = input("Context: ").strip()
    
    if not context:
        print("‚ùå No context provided. Exiting...")
        return None, None
    
    print(f"‚úÖ Context set: {context}")
    
    return document_paths, context


def run_command_line_analysis():
    """Run the category analyzer from command line"""
    import os
    
    # Get user input
    document_paths, context = get_user_input()
    if not document_paths or not context:
        return
    
    # Setup DSPy with Gemini
    print("\nü§ñ SETTING UP AI MODEL:")
    api_key = os.environ.get('paul2')
    if not api_key:
        print("‚ùå Error: 'paul2' environment variable not found!")
        print("Please set your Gemini API key in the environment variables.")
        return
    
    try:
        lm = dspy.LM('gemini/gemini-2.5-flash', api_key=api_key, max_tokens=8000)
        dspy.configure(lm=lm)
        print("‚úÖ AI model configured successfully")
    except Exception as e:
        print(f"‚ùå Error setting up AI model: {e}")
        return
    
    # Create Attachments objects from document paths
    print("\nüìé LOADING DOCUMENTS:")
    documents = []
    for path in document_paths:
        try:
            attachment = Attachments(path)
            documents.append(attachment)
            print(f"‚úÖ Loaded: {path}")
        except Exception as e:
            print(f"‚ùå Error loading '{path}': {e}")
    
    if not documents:
        print("‚ùå No documents could be loaded. Exiting...")
        return
    
    # Run category analysis
    print("\nüîç RUNNING CATEGORY ANALYSIS:")
    print("This may take a few moments...")
    
    try:
        analyzer = categories_analyzer()
        categories_result, final_context = analyzer.forward(
            documents=documents,
            context=context
        )
        
        print("\n" + "=" * 60)
        print("üìä CATEGORY ANALYSIS RESULTS")
        print("=" * 60)
        
        # Display discovered categories
        print("\nüè∑Ô∏è  DISCOVERED CATEGORIES:")
        if categories_result:
            if isinstance(categories_result, str):
                # If it's a string, split by common delimiters
                categories_list = [cat.strip() for cat in categories_result.replace(',', '\n').replace(';', '\n').split('\n') if cat.strip()]
            elif isinstance(categories_result, list):
                categories_list = categories_result
            else:
                categories_list = [str(categories_result)]
            
            for i, category in enumerate(categories_list, 1):
                print(f"   {i}. {category}")
            print(f"\n‚úÖ Found {len(categories_list)} categories")
        else:
            print("   No categories discovered")
        
        # Display final context
        print(f"\nüí≠ FINAL CONTEXT:")
        if final_context:
            context_preview = final_context[:500]
            if len(final_context) > 500:
                context_preview += "..."
            print(f"   {context_preview}")
        
        # Ask if user wants to save results
        print(f"\nüíæ SAVE RESULTS:")
        save_choice = input("Save results to file? (y/n): ").lower().strip()
        if save_choice == 'y':
            from datetime import datetime
            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            
            # Save categories
            foldername = "results/"
            categories_filename = f"category_analysis_{timestamp}.txt"
            with open(f"{foldername}{categories_filename}", 'w', encoding='utf-8') as f:
                f.write(f"Category Analysis Results\n")
                f.write(f"Generated: {timestamp}\n")
                f.write(f"="*50 + "\n\n")
                f.write(f"Original Context: {context}\n\n")
                f.write(f"Final Context: {final_context}\n\n")
                f.write(f"Discovered Categories:\n")
                if isinstance(categories_result, str):
                    categories_list = [cat.strip() for cat in categories_result.replace(',', '\n').replace(';', '\n').split('\n') if cat.strip()]
                elif isinstance(categories_result, list):
                    categories_list = categories_result
                else:
                    categories_list = [str(categories_result)]
                
                for i, category in enumerate(categories_list, 1):
                    f.write(f"{i}. {category}\n")
                
                f.write(f"\nDocuments Analyzed: {len(documents)}\n")
                f.write(f"Document Paths:\n")
                for path in document_paths:
                    f.write(f"  - {path}\n")
            
            print(f"‚úÖ Results saved to: {categories_filename}")
        
        print("\nüéâ Category analysis completed successfully!")
        
    except Exception as e:
        print(f"‚ùå Error during analysis: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    run_command_line_analysis()
